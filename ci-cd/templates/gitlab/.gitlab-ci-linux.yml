# GitLab CI/CD Pipeline for Linux Server / Docker Swarm Deployment

stages:
  - build
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# Load environment variables from .ci.env
before_script:
  - |
    if [ -f .ci.env ]; then
      export $(grep -v '^#' .ci.env | grep -v '^$' | xargs)
    fi

build-image:
  stage: build
  image: docker:24-cli
  services:
    - docker:24-dind
  before_script:
    - |
      if [ -f .ci.env ]; then
        export $(grep -v '^#' .ci.env | grep -v '^$' | xargs)
      fi
    - echo "IMAGE_NAME=$IMAGE_NAME"
    - echo "IMAGE_VERSION=$IMAGE_VERSION"
    - echo "PYTHON_VERSION=$PYTHON_VERSION"
  script:
    # Login to Docker registry
    - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
    
    # Determine image tag
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        IMAGE_TAG="$CI_COMMIT_TAG"
      elif [ -n "$IMAGE_VERSION" ]; then
        IMAGE_TAG="$IMAGE_VERSION"
      else
        IMAGE_TAG="${CI_COMMIT_SHORT_SHA}"
      fi
    
    - echo "Building image with tag: $IMAGE_TAG"
    
    # Build and push image
    - |
      docker buildx build \
        --build-arg PYTHON_VERSION="${PYTHON_VERSION:-3.13}-slim" \
        --build-arg IMAGE_TAG="$IMAGE_TAG" \
        -t "$IMAGE_NAME:$IMAGE_TAG" \
        -t "$IMAGE_NAME:latest" \
        -f "${DOCKERFILE_PATH:-Dockerfile}" \
        .
    
    - docker push "$IMAGE_NAME:$IMAGE_TAG"
    - docker push "$IMAGE_NAME:latest"
    
    - echo "✅ Image pushed successfully!"
    - echo "   $IMAGE_NAME:$IMAGE_TAG"
    - echo "   $IMAGE_NAME:latest"
    
    # Save image tag for deployment stage
    - echo "IMAGE_TAG=$IMAGE_TAG" > build.env
  artifacts:
    reports:
      dotenv: build.env
  only:
    - main
    - master
    - dev
    - tags
  tags:
    - docker

deploy-production:
  stage: deploy
  image: alpine:latest
  dependencies:
    - build-image
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    # Add known hosts
    - |
      if [ -n "$SSH_KNOWN_HOSTS" ]; then
        echo "$SSH_KNOWN_HOSTS" >> ~/.ssh/known_hosts
      else
        ssh-keyscan $DEPLOY_SERVER >> ~/.ssh/known_hosts
      fi
    - chmod 644 ~/.ssh/known_hosts
    # Load .ci.env
    - |
      if [ -f .ci.env ]; then
        export $(grep -v '^#' .ci.env | grep -v '^$' | xargs)
      fi
  script:
    - echo "Deploying to $DEPLOY_SERVER..."
    
    # Copy docker-compose.prod.yml to server
    - scp docker-compose.prod.yml $DEPLOY_USER@$DEPLOY_SERVER:$DEPLOY_PATH/
    
    # Deploy on server
    - |
      ssh $DEPLOY_USER@$DEPLOY_SERVER << EOF
        cd $DEPLOY_PATH
        
        # Set image tag
        export IMAGE_NAME=$IMAGE_NAME
        export IMAGE_TAG=$IMAGE_TAG
        
        # Pull latest image
        docker pull \${IMAGE_NAME}:\${IMAGE_TAG}
        
        # Stop and remove old containers
        docker compose -f docker-compose.prod.yml down
        
        # Start new containers
        docker compose -f docker-compose.prod.yml up -d
        
        # Show status
        docker compose -f docker-compose.prod.yml ps
      EOF
    
    - echo "✅ Deployment successful!"
    - echo "   Server: $DEPLOY_SERVER"
    - echo "   Path: $DEPLOY_PATH"
    - echo "   Image: $IMAGE_NAME:$IMAGE_TAG"
  only:
    - main
    - master
  when: manual
  environment:
    name: production
    url: https://your-production-url.com
  tags:
    - docker
